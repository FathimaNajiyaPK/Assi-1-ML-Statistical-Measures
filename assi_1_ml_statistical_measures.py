# -*- coding: utf-8 -*-
"""Assi 1 ML Statistical measures.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SPBdYu3fpIytK0WoJ9jD_GW9yx03xOgg
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import zscore

df = pd.read_csv("house_price.csv")

df

# View first few rows
print(df.head())

# Basic info
print(df.info())

# Summary statistics
print(df.describe())

# Check for missing values
print(df.isnull().sum())

df.duplicated().sum()

df = df.drop_duplicates()

df.duplicated().sum()

# Boxplot of each column
plt.figure(figsize=(12, 8))
sns.boxplot(df)
plt.xticks(rotation=90)
plt.title('Boxplot of Features')
plt.show()

numeric_cols = ["total_sqft", "bath", "price", "bhk", "price_per_sqft"]

for col in numeric_cols:
    plt.figure(figsize=(8, 5))
    plt.hist(df[col], bins=50, edgecolor="black", alpha=0.7)
    plt.xlabel(col)
    plt.ylabel("Frequency")
    plt.title(f"Distribution of {col}")
    plt.grid(axis="y", linestyle="--", alpha=0.7)
    plt.show()

"""# Outlier Removal Methods
  # a. Mean & Standard Deviation



"""

num_cols = ["total_sqft", "bath", "price", "bhk", "price_per_sqft"]

df_cap_mean_std = df.copy()

outliers_removed = {}

for col in num_cols:
    mean = df[col].mean()
    std = df[col].std()
    lower_bound = mean - 3 * std
    upper_bound = mean + 3 * std

    num_outliers = ((df[col] < lower_bound) | (df[col] > upper_bound)).sum()
    outliers_removed[col] = num_outliers
    print(f"{col}: {num_outliers} outliers detected")

    df_cap_mean_std[col] = np.clip(df_cap_mean_std[col], lower_bound, upper_bound)
df_cap_mean_std

"""# b. percentile method"""

df_cap_percentile = df.copy()

outliers_removed = {}

for col in num_cols:
    lower_bound = np.percentile(df[col], 1)
    upper_bound = np.percentile(df[col], 99)

    num_outliers = ((df[col] < lower_bound) | (df[col] > upper_bound)).sum()
    outliers_removed[col] = num_outliers
    print(f"{col}: {num_outliers} outliers detected")

    df_cap_percentile[col] = np.clip(df_cap_percentile[col], lower_bound, upper_bound)
df_cap_percentile

"""# c. IQR method"""

df_trim_iqr = df.copy()

outliers_removed = {}

for col in num_cols:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    num_outliers = ((df[col] < lower_bound) | (df[col] > upper_bound)).sum()
    outliers_removed[col] = num_outliers
    print(f"{col}: {num_outliers} outliers detected")

    df_trim_iqr = df_trim_iqr[(df_trim_iqr[col] >= lower_bound) & (df_trim_iqr[col] <= upper_bound)]
df_trim_iqr

"""# d. zscore method"""

from scipy import stats

df_impute_zscore = df.copy()

outliers_removed = {}

for col in num_cols:
    z_scores = stats.zscore(df[col])
    abs_z_scores = np.abs(z_scores)

    num_outliers = (abs_z_scores > 3).sum()
    outliers_removed[col] = num_outliers
    print(f"{col}: {num_outliers} outliers detected")

    mean_value = df[col].mean()
    df_impute_zscore.loc[abs_z_scores > 3, col] = mean_value
df_impute_zscore

"""*Q3. Create a box plot and use this to determine which method seems to work best to remove outliers for this data?***"""

import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=5, figsize=(18, 5))
fig.suptitle("Boxplot Comparison of Outlier Removal Methods", fontsize=14)

datasets = {"Original Data": df,"Mean & Std": df_cap_mean_std,"Percentile": df_cap_percentile,"IQR": df_trim_iqr,"Z-Score": df_impute_zscore}

for i, (name, dataset) in enumerate(datasets.items()):
    axes[i].boxplot(dataset["price"], vert=True, patch_artist=True)
    axes[i].set_title(name)

plt.tight_layout()
plt.show()

# IOR seems to work better



"""**Q4. Draw histplot to check the normality of the column(price per sqft column) and perform transformations if needed. Check the skewness and kurtosis before and after the transformation.**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import skew, kurtosis

# Load the dataset
df = pd.read_csv("house_price.csv")
# Extract the price_per_sqft column
if "price_per_sqft" not in df.columns:
    raise ValueError("Column 'price_per_sqft' not found in dataset.")

price_per_sqft = df["price_per_sqft"]

# Skewness and Kurtosis before transformation
original_skewness = skew(price_per_sqft)
original_kurtosis = kurtosis(price_per_sqft)

# Plot histogram before transformation
plt.figure(figsize=(10, 5))
sns.histplot(price_per_sqft, bins=50, kde=True)
plt.title("Histogram of Price per Sqft (Before Transformation)")
plt.xlabel("Price per Sqft")
plt.ylabel("Frequency")
plt.show()

print(f"Skewness before transformation: {original_skewness:.2f}")
print(f"Kurtosis before transformation: {original_kurtosis:.2f}")

# Apply Log Transformation (to reduce skewness)
price_per_sqft_transformed = np.log1p(price_per_sqft)

# Skewness and Kurtosis after transformation
transformed_skewness = skew(price_per_sqft_transformed)
transformed_kurtosis = kurtosis(price_per_sqft_transformed)

# Plot histogram after transformation
plt.figure(figsize=(10, 5))
sns.histplot(price_per_sqft_transformed, bins=50, kde=True)
plt.title("Histogram of Price per Sqft (After Log Transformation)")
plt.xlabel("Log(Price per Sqft)")
plt.ylabel("Frequency")
plt.show()

print(f"Skewness after transformation: {transformed_skewness:.2f}")
print(f"Kurtosis after transformation: {transformed_kurtosis:.2f}")

"""**Q5. Check the correlation between all the numerical columns and plot heatmap.**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

correlation_matrix = df.corr(numeric_only=True)

plt.figure(figsize=(10, 6))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.5)
plt.title("Correlation Heatmap of Numerical Columns")
plt.show()

"""**Q6. Draw Scatter plot between the variables to check the correlation between them**"""

sns.pairplot(df, diag_kind='kde', corner=True)
plt.suptitle("Scatter Plot Matrix to Check Correlations", y=1.02)
plt.show()

